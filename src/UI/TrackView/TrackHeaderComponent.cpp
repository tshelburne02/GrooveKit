// [Generated by Junie] Contributor Note:
// The following file contains code contributions by Junie to enable in-place editing of the track label.
#include "TrackHeaderComponent.h"
#include "../AppEngine/AppEngine.h"
#include "TrackComponent.h"
#include "../../AppEngine/AppEngine.h" // Full definition needed for implementation (Written by Claude Code)

TrackHeaderComponent::TrackHeaderComponent (AppEngine& engine)
    : appEngine (&engine)
{
    addAndMakeVisible (instrumentButton);
    addAndMakeVisible (instrumentMenuButton);
    addAndMakeVisible (settingsButton);
    addAndMakeVisible (trackNameLabel);
    addAndMakeVisible (muteTrackButton);
    addAndMakeVisible (soloTrackButton);
    addAndMakeVisible (recordArmButton);

    instrumentButton.setButtonText ("Instrument");

    instrumentButton.onClick = [this]() {
        listeners.call ([] (Listener& l) { l.onInstrumentClicked(); });
    };

    instrumentMenuButton.onClick = [this]() {
        listeners.call ([] (Listener& l) { l.onInstrumentMenuRequested(); });
    };

    settingsButton.onClick = [this]() {
        listeners.call ([] (Listener& l) { l.onSettingsClicked(); });
    };

    muteTrackButton.setClickingTogglesState (true);
    muteTrackButton.setColour (juce::TextButton::buttonOnColourId, juce::Colours::red);
    muteTrackButton.setColour (juce::TextButton::buttonColourId, juce::Colours::darkgrey);
    muteTrackButton.setColour (juce::TextButton::textColourOnId, juce::Colours::white);
    muteTrackButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);
    muteTrackButton.onClick = [this]() {
        const bool nowMuted = muteTrackButton.getToggleState();
        listeners.call ([&] (Listener& l) { l.onMuteToggled (nowMuted); });
    };

    soloTrackButton.setClickingTogglesState (true);
    soloTrackButton.setColour (juce::TextButton::buttonOnColourId, juce::Colours::yellow);
    soloTrackButton.setColour (juce::TextButton::buttonColourId, juce::Colours::darkgrey);
    soloTrackButton.setColour (juce::TextButton::textColourOnId, juce::Colours::black);
    soloTrackButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);
    soloTrackButton.onClick = [this] {
        const bool nowSolo = soloTrackButton.getToggleState();
        listeners.call ([&] (Listener& l) { l.onSoloToggled (nowSolo); });
    };

    recordArmButton.setClickingTogglesState (true);
    recordArmButton.setColour (juce::TextButton::buttonOnColourId, juce::Colours::darkred);
    recordArmButton.setColour (juce::TextButton::buttonColourId, juce::Colours::darkgrey);
    recordArmButton.setColour (juce::TextButton::textColourOnId, juce::Colours::black);
    recordArmButton.setColour (juce::TextButton::textColourOffId, juce::Colours::white);
    recordArmButton.onClick = [this] {
        const bool nowArmed = recordArmButton.getToggleState();
        listeners.call ([&] (Listener& l) { l.onRecordArmToggled (nowArmed); });
    };

    trackNameLabel.setFont (juce::Font (juce::FontOptions (15.f)));
    trackNameLabel.setColour (juce::Label::textColourId, juce::Colours::white.darker (0.1));
    trackNameLabel.setJustificationType (juce::Justification::centred);

    // [Generated by Junie] Make the track name label editable on double-click.
    // This allows users to rename the track by double-clicking on the label.
    // Using setEditable(false, true, false) enables editing only on double-click, not single-click.
    trackNameLabel.setEditable (false, true, false);

    // Use I-beam cursor when hovering over the track name to indicate text editing
    trackNameLabel.setMouseCursor (juce::MouseCursor::IBeamCursor);

    instrumentMenuButton.setButtonText (juce::String::fromUTF8 (u8"\u25BE"));
    instrumentMenuButton.setWantsKeyboardFocus (false);
    instrumentMenuButton.setMouseCursor (juce::MouseCursor::PointingHandCursor);
    instrumentMenuButton.setTooltip ("Choose instrument");
    instrumentButton.setTooltip ("Open instrument editor");

    instrumentButton.setConnectedEdges     (juce::Button::ConnectedOnRight);
    instrumentMenuButton.setConnectedEdges (juce::Button::ConnectedOnLeft);

    // Register as listener to handle track name changes (Written by Claude Code)
    trackNameLabel.addListener (this);

    setTrackType (TrackType::Instrument);

    auto bg      = juce::Colour (0xFF2D3943);
    auto bgOver  = bg.brighter (0.08f);
    auto bgDown  = bg.darker   (0.10f);
    auto fg      = juce::Colours::white;
    for (auto* b : { &instrumentButton, &instrumentMenuButton })
    {
        b->setColour (juce::TextButton::buttonColourId,     bg);
        b->setColour (juce::TextButton::buttonOnColourId,   bgDown);
        b->setColour (juce::TextButton::textColourOnId,     fg);
        b->setColour (juce::TextButton::textColourOffId,    fg);

        #if JUCE_MAJOR_VERSION >= 8
        b->setColour (juce::TextButton::buttonOver, bgOver);
        #else
        b->setColour (juce::TextButton::buttonOverColourId, bgOver);
        #endif
    }

}

TrackHeaderComponent::~TrackHeaderComponent() = default;

void TrackHeaderComponent::setTrackName (juce::String name)
{
    // Only update UI, don't modify engine state (Written by Claude Code)
    // This method is called programmatically to sync UI with engine state
    trackNameLabel.setText (std::move (name), juce::dontSendNotification);
}

// Handle user editing the track name label (Written by Claude Code)
void TrackHeaderComponent::labelTextChanged (juce::Label* labelThatHasChanged)
{
    if (labelThatHasChanged == &trackNameLabel)
    {
        // Use stored trackIndex instead of searching component hierarchy (Written by Claude Code)
        if (trackIndex >= 0)
        {
            const juce::String newName = trackNameLabel.getText();
            appEngine->setTrackName (trackIndex, newName);
        }
    }
}

void TrackHeaderComponent::setTrackType (const TrackType type)
{
    // Store track type without overwriting the track name (Written by Claude Code)
    // Track name should be set independently via setTrackName()
    trackType = type;
}

void TrackHeaderComponent::setTrackIndex (int newIndex)
{
    trackIndex = newIndex;
    refreshInstrumentButton();
}

void TrackHeaderComponent::setInstrumentLabel (const juce::String& text)
{
    auto label = text;
    if (label.isEmpty())
        label = "Instrument";

    instrumentButton.setButtonText (label);
}

bool TrackHeaderComponent::isMuted() const { return muteTrackButton.getToggleState(); }
void TrackHeaderComponent::setMuted (const bool shouldBeMuted)
{
    muteTrackButton.setToggleState (shouldBeMuted, juce::dontSendNotification);
}

bool TrackHeaderComponent::isSolo() const { return soloTrackButton.getToggleState(); }
void TrackHeaderComponent::setSolo (const bool shouldBeSolo)
{
    soloTrackButton.setToggleState (shouldBeSolo, juce::dontSendNotification);
}

bool TrackHeaderComponent::isArmed() const { return recordArmButton.getToggleState(); }
void TrackHeaderComponent::setArmed (const bool shouldBeArmed)
{
    recordArmButton.setToggleState (shouldBeArmed, juce::dontSendNotification);
}

void TrackHeaderComponent::setArmButtonEnabled (const bool enabled) { recordArmButton.setEnabled (enabled); }

void TrackHeaderComponent::setDimmed (const bool dim)
{
    setAlpha (dim ? 0.6f : 1.0f);
}

void TrackHeaderComponent::refreshInstrumentButton()
{
    if (! appEngine || trackIndex < 0)
    {
        instrumentButton.setButtonText ("Instrument");
        return;
    }

    // For drum tracks, always show "Drum Sampler"
    if (trackType == TrackType::Drum)
    {
        instrumentButton.setButtonText ("Drum Sampler");
        return;
    }

    // For instrument tracks, use the dynamic label from engine
    instrumentButton.setButtonText (
        appEngine->getInstrumentLabelForTrack (trackIndex));
}
void TrackHeaderComponent::paint (juce::Graphics& g)
{
    auto bounds = getLocalBounds().toFloat().reduced (2.0f);

    g.setColour (juce::Colour (0xFF495057));

    // Rounded background
    const float radius = 10.0f;
    g.fillRoundedRectangle (bounds, radius);

    // Border
    g.setColour (juce::Colours::white.withAlpha (0.20f));
    g.drawRoundedRectangle (bounds, radius, 1.5f);
    refreshInstrumentButton();

}

void TrackHeaderComponent::resized()
{
    auto area = getLocalBounds().reduced (6);
    constexpr int titleH = 20;
    constexpr int buttonH = 25;
    constexpr int gap    = 4;
    constexpr int menuW  = 28;  // square ▼

    // Title
    trackNameLabel.setBounds (area.removeFromTop (titleH));

    // Split button row
    auto row  = area.removeFromTop (buttonH);

    // For drum tracks, hide the dropdown menu button (instrument cannot be changed)
    const bool isDrum = (trackType == TrackType::Drum);
    if (isDrum)
    {
        instrumentButton.setBounds (row);
        instrumentMenuButton.setVisible (false);
        // Clear connected edges so drum sampler button has rounded corners on all sides
        instrumentButton.setConnectedEdges (0);
    }
    else
    {
        auto left = row.removeFromLeft (row.getWidth() - menuW);
        auto right = row.removeFromLeft (menuW);
        instrumentButton.setBounds (left);
        instrumentMenuButton.setBounds (right);
        instrumentMenuButton.setVisible (true);
        // Restore connected edges for instrument tracks (button connects to dropdown)
        instrumentButton.setConnectedEdges (juce::Button::ConnectedOnRight);
    }

    // Remaining controls stacked in the leftover area
    juce::FlexBox fb;
    fb.flexDirection   = juce::FlexBox::Direction::column;
    fb.justifyContent  = juce::FlexBox::JustifyContent::flexStart;
    fb.alignItems      = juce::FlexBox::AlignItems::stretch;

    const auto margin = juce::FlexItem::Margin (2, 0, 2, 0);
    fb.items.add (juce::FlexItem (settingsButton).withHeight (buttonH).withMargin (margin));
    fb.items.add (juce::FlexItem (muteTrackButton).withHeight (buttonH).withMargin (margin));
    fb.items.add (juce::FlexItem (soloTrackButton).withHeight (buttonH).withMargin (margin));
    fb.items.add (juce::FlexItem (recordArmButton).withHeight (buttonH).withMargin (margin));

    fb.performLayout (area);  // <— layout into the leftover area
}